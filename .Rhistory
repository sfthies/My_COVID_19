bi_sec_break<-function(ts_dat){
log_ts_dat <- log(ts_dat)
log_ts_dat[is.finite(log_ts_dat)==F]<-NA
t<-1:length(ts_dat)
l2<- function(t0){
t_int <- t>=t0
lm_temp <- lm(log_ts_dat~t+t*t_int)
return(summary(lm_temp)$r.squared)
}
t0<-which.max(sapply(t, l2))
return(t0)
}
#Determine breaks:
breaks<-apply(dat_con_2[,countries],2, function(x) bi_sec_break(x))
#Plot breakpoints:
par(mfrow= c(3,4), mar = c(4,4,.1,.1), mgp = c(2,1,0))
for(c in countries){
plot(1:nrow(dat_con_2), dat_con_2[,c], ylab = c, xlab = 'Day', log = "y")
abline(v = breaks[c], col = 2, lty = 2)
}
est_growth <- sapply(countries, function(c){
temp_dat<-log(dat_con_2[breaks[c]:nrow(dat_con_2),c])
temp_t<-1:length(temp_dat)
summary(lm(temp_dat~temp_t))$coef[2,1:2]
})
est_growth <- as.data.frame(t(est_growth))
est_growth[,'Country']<-row.names(est_growth)
plot_ly(y = ~(exp(Estimate)-1) , x = ~Country, data = est_growth, type = 'bar', error_y = ~list(array = (est_growth$`Std. Error`*exp(est_growth$Estimate)^2),
color = 'black')) %>%
layout(yaxis = list(title = 'Estimated growth rate'))
est_growth[,'Double'] <- log(2)/log(1+est_growth$Estimate)
plot_ly(y = ~Double , x = ~Country, data = est_growth, type = 'bar') %>%
layout(yaxis = list(title = 'Estimated days to double'))
est_growth[,'Ten'] <- log(10)/log(1+est_growth$Estimate)
plot_ly(y = ~Ten , x = ~Country, data = est_growth, type = 'bar') %>%
layout(yaxis = list(title = 'Estimated days to double'))
dat_con_2[,c]
dat_con_2$Date
dat_con_2[,c]
# Estimate fatality -------------------------------------------------------
c <- 'Germany'
dat_con_2[,c]
dat_dea_2
dat_dea_2[,c]
tau<-20
Tmax<-nrow(dat_con_2)
dat_con_2[1:(Tmax-tau),c]
dat_dea_2[tau:Tmax,c]
dat_con_2[1:(Tmax-tau+1),c]
dat_dea_2[tau:Tmax,c]/dat_con_2[1:(Tmax-tau+1),c]
tau<-15
Tmax<-nrow(dat_con_2)
dat_dea_2[tau:Tmax,c]/dat_con_2[1:(Tmax-tau+1),c]
tau<-1
Tmax<-nrow(dat_con_2)
dat_dea_2[tau:Tmax,c]/dat_con_2[1:(Tmax-tau+1),c]
tau<-15
Tmax<-nrow(dat_con_2)
dat_dea_2[tau:Tmax,c]/dat_con_2[1:(Tmax-tau+1),c]
fatals<-dat_dea_2[tau:Tmax,c]/dat_con_2[1:(Tmax-tau+1),c]
fatals[fatals>0]
mean(fatals[fatals>0], na.rm = T)
# Estimate fatality -------------------------------------------------------
c <- 'Italy'
tau<-15
Tmax<-nrow(dat_con_2)
fatals<-dat_dea_2[tau:Tmax,c]/dat_con_2[1:(Tmax-tau+1),c]
mean(fatals[fatals>0], na.rm = T)
fatals
## Select all countries with more than 100 reported cases
countries <- colnames(dat_con_2)[which(dat_con_2[nrow(dat_con_2),-ncol(dat_con_2)]>10)]
countries
#Set working directory:
setwd("C:/Users/Stephan/Documents/GitHub/My_COVID_19/")
#Set path for John Hopkins Github COVID 19 data:
jhu_data_path <- "C:/Users/Stephan/Documents/GitHub/COVID-19"
# Libaries ----------------------------------------------------------------
require(plotly)
require(tidyr)
require(dplyr)
add.alpha <- function(col, alpha=1){
if(missing(col))
stop("Please provide a vector of colours.")
apply(sapply(col, col2rgb)/255, 2,
function(x)
rgb(x[1], x[2], x[3], alpha=alpha))
}
## Read Data from JHU:
#Confirmed:
dat_con <- read.csv(paste0(jhu_data_path,"csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Confirmed.csv"))
paste0(jhu_data_path,"/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Confirmed.csv")
## Read Data from JHU:
#Confirmed:
dat_con <- read.csv(paste0(jhu_data_path,"/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Confirmed.csv"))
#Deaths:
dat_dea <- read.csv(paste0(jhu_data_path,"/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Deaths.csv"))
#Recovered
dat_rec <- read.csv(paste0(jhu_data_path,"/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Recovered.csv"))
##Bring into correct format:
#Confirmed:
dat_con_2 <- t(aggregate(dat_con[,-(1:4)], list(dat_con$Country.Region), FUN = sum))
colnames(dat_con_2) <- dat_con_2[1,]
dat_con_2 <- dat_con_2[-1,]
class(dat_con_2) <- 'numeric'
dat_con_2 <- as.data.frame(dat_con_2)
dat_con_2$Date <- as.Date(gsub("X", "",rownames(dat_con_2)), format = '%m.%d.%y')
rownames(dat_con_2) <- 1:nrow(dat_con_2)
#Deaths:
dat_dea_2 <- t(aggregate(dat_dea[,-(1:4)], list(dat_dea$Country.Region), FUN = sum))
colnames(dat_dea_2) <- dat_dea_2[1,]
dat_dea_2 <- dat_dea_2[-1,]
class(dat_dea_2) <- 'numeric'
dat_dea_2 <- as.data.frame(dat_dea_2)
dat_dea_2$Date <- as.Date(gsub("X", "",rownames(dat_dea_2)), format = '%m.%d.%y')
rownames(dat_dea_2) <- 1:nrow(dat_dea_2)
#Recovered:
dat_rec_2 <- t(aggregate(dat_rec[,-(1:4)], list(dat_rec$Country.Region), FUN = sum))
colnames(dat_rec_2) <- dat_rec_2[1,]
dat_rec_2 <- dat_rec_2[-1,]
class(dat_rec_2) <- 'numeric'
dat_rec_2 <- as.data.frame(dat_rec_2)
dat_rec_2$Date <- as.Date(gsub("X", "",rownames(dat_rec_2)), format = '%m.%d.%y')
rownames(dat_rec_2) <- 1:nrow(dat_rec_2)
View(dat_con_2)
## Select all countries with more than 100 reported cases
countries <- colnames(dat_con_2)[which(dat_con_2[nrow(dat_con_2),-ncol(dat_con_2)]>10)]
#Confirmed:
plt <- plot_ly(x = ~Date, data = dat_con_2)
for(c in countries){
plt <- plt %>% add_lines(y = dat_con_2[,c], name = c)
}
plt %>% layout(yaxis = list(title = 'Confirmed cases'))
## Select all countries with more than 100 reported cases
countries <- colnames(dat_con_2)[which(dat_con_2[nrow(dat_con_2),-ncol(dat_con_2)]>1000)]
#Confirmed:
plt <- plot_ly(x = ~Date, data = dat_con_2)
for(c in countries){
plt <- plt %>% add_lines(y = dat_con_2[,c], name = c)
}
plt %>% layout(yaxis = list(title = 'Confirmed cases'))
plt <- plt %>% layout(yaxis = list(title = 'Confirmed cases (log scale)', type = 'log'))
plt
bi_sec_break<-function(ts_dat){
log_ts_dat <- log(ts_dat)
log_ts_dat[is.finite(log_ts_dat)==F]<-NA
t<-1:length(ts_dat)
l2<- function(t0){
t_int <- t>=t0
lm_temp <- lm(log_ts_dat~t+t*t_int)
return(summary(lm_temp)$r.squared)
}
t0<-which.max(sapply(t, l2))
return(t0)
}
#Determine breaks:
breaks<-apply(dat_con_2[,countries],2, function(x) bi_sec_break(x))
#Plot breakpoints:
par(mfrow= c(3,4), mar = c(4,4,.1,.1), mgp = c(2,1,0))
for(c in countries){
plot(1:nrow(dat_con_2), dat_con_2[,c], ylab = c, xlab = 'Day', log = "y")
abline(v = breaks[c], col = 2, lty = 2)
}
est_growth <- sapply(countries, function(c){
temp_dat<-log(dat_con_2[breaks[c]:nrow(dat_con_2),c])
temp_t<-1:length(temp_dat)
summary(lm(temp_dat~temp_t))$coef[2,1:2]
})
est_growth <- as.data.frame(t(est_growth))
est_growth[,'Country']<-row.names(est_growth)
plot_ly(y = ~(exp(Estimate)-1) , x = ~Country, data = est_growth, type = 'bar', error_y = ~list(array = (est_growth$`Std. Error`*exp(est_growth$Estimate)^2),
color = 'black')) %>%
layout(yaxis = list(title = 'Estimated growth rate'))
est_growth[,'Double'] <- log(2)/log(1+est_growth$Estimate)
est_growth[,'Ten'] <- log(10)/log(1+est_growth$Estimate)
plot_ly(y = ~Double , x = ~Country, data = est_growth, type = 'bar') %>%
layout(yaxis = list(title = 'Estimated days to double'))
plot_ly(y = ~Ten , x = ~Country, data = est_growth, type = 'bar') %>%
layout(yaxis = list(title = 'Estimated days to double'))
plot_ly(y = ~Ten , x = ~Country, data = est_growth, type = 'bar') %>%
layout(yaxis = list(title = 'Estimated days to increase by ten'))
#Function takes t
error_fun<-function(tau, c){
e<-dat_con_2[1:(nrow(dat_con_2)-tau),c]  -(dat_dea_2[(tau+1):(nrow(dat_dea_2)),c]+dat_rec_2[(tau+1):(nrow(dat_rec_2)),c] )
sum(e^2)/(nrow(dat_con_2))
}
#Obtain least square estimate for single country:
c <- 'Germany'
sapply(countries, function(c) optimise(function(x) error_fun(x,c), interval=c(1,30))$minimum)
#Obtain least square estimate across countries:
optimise(function(x) sum(sapply(countries, function(c) error_fun(x, c))), interval=c(1,30))
sapply(1:30, function(x) error_fun(x,c)
)
which.min(sapply(1:30, function(x) error_fun(x,c))
)
which.min(sapply(1:30, function(x) error_fun(x,c)))
sapply(countries, function(c) which.min(sapply(1:30, function(x) error_fun(x,c))))
sapply(1:30, function(x) sum(sapply(countries, function(c) error_fun(x, c))))
#Obtain least square estimate across countries:
which.min(sapply(1:30, function(x) sum(sapply(countries, function(c) error_fun(x, c)))))
## Estimate recovery time or time to death seperately
error_fun_sep<-function(tau1, tau2, c){
tau<-max(tau1, tau2)
e<-dat_con_2[1:(nrow(dat_con_2)-tau),c]  -(dat_dea_2[1:(nrow(dat_con_2)-tau)+tau2,c]+dat_rec_2[1:(nrow(dat_con_2)-tau)+tau1,c] )
sum(e^2)/(nrow(dat_con_2))
}
sapply(1:30, function(y) sapply(1:30, function(x) error_fun_sep(x,y,c)))
which.min(sapply(1:30, function(y) sapply(1:30, function(x) error_fun_sep(x,y,c))),arr.ind = T)
sapply(1:30, function(y) sapply(1:30, function(x) error_fun_sep(x,y,c)))
temp<-sapply(1:30, function(y) sapply(1:30, function(x) error_fun_sep(x,y,c)))
which(temp == min(temp))
which(temp == min(temp), arr.ind = T)
names(taus)<-c('tau1','tau2')
taus<-which(temp == min(temp), arr.ind = T)
names(taus)<-c('tau1','tau2')
taus
colnames(taus)<-c('tau1','tau2')
taus
temp<-sapply(1:30, function(y) sapply(1:30, function(x) error_fun_sep(x,y,c)))
taus<-which(temp == min(temp), arr.ind = T)
colnames(taus)<-c('tau1','tau2')
taus
sapply(countries, function(c){
temp<-sapply(1:30, function(y) sapply(1:30, function(x) error_fun_sep(x,y,c)))
taus<-which(temp == min(temp), arr.ind = T)
colnames(taus)<-c('tau1','tau2')})
sapply(countries, function(c){
temp<-sapply(1:30, function(y) sapply(1:30, function(x) error_fun_sep(x,y,c)))
taus<-which(temp == min(temp), arr.ind = T)
colnames(taus)<-c('tau1','tau2')
return(taus)})
sapply(countries, function(c){
temp<-sapply(5:25, function(y) sapply(5:25, function(x) error_fun_sep(x,y,c)))
taus<-which(temp == min(temp), arr.ind = T)
colnames(taus)<-c('tau1','tau2')
return(taus)})
temp
image(temp)
# newly infected per day:
is<-diff(dat_con_2$Germany[34:53])
res<-rep(NA, 18)
for(tau in 1:18){
t = 1
alpha_ps <- sapply(1:(length(is)-tau), function(t) is[tau+t]/sum(is[1:tau+t-1]))
alpha_p <-mean(alpha_ps)
res[tau]<-mean(alpha_p*tau)
}
fitted<-is
fitted[(tau+1): length(is)]<-NA
for(t in 1:(length(is)-tau)){
fitted[tau+t]<-sum(fitted[1:tau+t-1])*alpha_p
}
plot(is)
lines(fitted, lty = 2)
res
is
len(#different)
len(is)
)
len(is)
length(is)
#newly infected per day
Tmax<-nrow(dat_con_2)
Tmax
is<-diff(dat_con_2$Germany[34:Tmax])
is
c<-'Germany'
breaks[c]
#newly infected per day
Tstart<-breaks[c]
#newly infected per day
(Tstart<-breaks[c])
(Tmax<-nrow(dat_con_2))
is<-diff(dat_con_2[Tstart:Tmax,c])
i
is
#Different R0 depending on tau:
res<-rep(NA, 18)
res
#Different R0 depending on tau:
res<-rep(NA, length(is))
res
res
for(tau in 1:length(is)){
alpha_ps <- sapply(1:(length(is)-tau), function(t) is[tau+t]/sum(is[1:tau+t-1]))
alpha_p <-mean(alpha_ps)
res[tau]<-mean(alpha_p*tau)
}
res[tau]
res
fitted<-is
fitted[(tau+1): length(is)]<-NA
for(t in 1:(length(is)-tau)){
fitted[tau+t]<-sum(fitted[1:tau+t-1])*alpha_p
}
plot(is)
lines(fitted, lty = 2)
alpha_p <-mean(alpha_ps)
alpha_p
res
#Different R0
res
#Different resulting R0:
res
#select one tau:
tau<-12
res[12]
#And calculate respective alpha_p
alpha_p<-res[12]/12
alpha_p
fitted<-is
fitted[(tau+1): length(is)]<-NA
for(t in 1:(length(is)-tau)){
fitted[tau+t]<-sum(fitted[1:tau+t-1])*alpha_p
}
plot(is)
lines(fitted, lty = 2)
# Estimate infection parameters ------------------------------------------
par(mfrow=c(1,1))
#Function takes t
error_fun<-function(tau, c){
e<-dat_con_2[1:(nrow(dat_con_2)-tau),c]  -(dat_dea_2[(tau+1):(nrow(dat_dea_2)),c]+dat_rec_2[(tau+1):(nrow(dat_rec_2)),c] )
sum(e^2)/(nrow(dat_con_2))
}
#Obtain least square estimate for single countries:
c <- 'Germany'
sapply(countries, function(c) which.min(sapply(1:30, function(x) error_fun(x,c))))
#Obtain least square estimate across countries:
which.min(sapply(1:30, function(x) sum(sapply(countries, function(c) error_fun(x, c)))))
## Estimate recovery time or time to death seperately
error_fun_sep<-function(tau1, tau2, c){
tau<-max(tau1, tau2)
e<-dat_con_2[1:(nrow(dat_con_2)-tau),c]  -(dat_dea_2[1:(nrow(dat_con_2)-tau)+tau2,c]+dat_rec_2[1:(nrow(dat_con_2)-tau)+tau1,c] )
sum(e^2)/(nrow(dat_con_2))
}
#Doesnt work too well:
sapply(countries, function(c){
temp<-sapply(5:25, function(y) sapply(5:25, function(x) error_fun_sep(x,y,c)))
taus<-which(temp == min(temp), arr.ind = T)
colnames(taus)<-c('tau1','tau2')
return(taus)}
)
c<-'Germany'
#newly infected per day
(Tstart<-breaks[c])
(Tmax<-nrow(dat_con_2))
is<-diff(dat_con_2[Tstart:Tmax,c])
#Different R0 depending on tau:
res<-rep(NA, length(is))
for(tau in 1:length(is)){
alpha_ps <- sapply(1:(length(is)-tau), function(t) is[tau+t]/sum(is[1:tau+t-1]))
alpha_p <-mean(alpha_ps)
res[tau]<-mean(alpha_p*tau)
}
#Different resulting R0:
res
#select one tau:
tau<-12
#And calculate respective alpha_p
alpha_p<-res[12]/12
fitted<-is
fitted[(tau+1): length(is)]<-NA
for(t in 1:(length(is)-tau)){
fitted[tau+t]<-sum(fitted[1:tau+t-1])*alpha_p
}
plot(is)
lines(fitted, lty = 2)
# Estimate fatality -------------------------------------------------------
c <- 'Italy'
tau<-15
Tmax<-nrow(dat_con_2)
fatals<-dat_dea_2[tau:Tmax,c]/dat_con_2[1:(Tmax-tau+1),c]
mean(fatals[fatals>0], na.rm = T)
# Estimate fatality -------------------------------------------------------
c <- 'Germany'
tau<-15
Tmax<-nrow(dat_con_2)
fatals<-dat_dea_2[tau:Tmax,c]/dat_con_2[1:(Tmax-tau+1),c]
mean(fatals[fatals>0], na.rm = T)
### COVID 19 Simulation ####
setwd("C:/Users/Stephan/Documents/GitHub/My_COVID_19/")
# Functions: --------------------------------------------------------------
add.alpha <- function(col, alpha=1){
if(missing(col))
stop("Please provide a vector of colours.")
apply(sapply(col, col2rgb)/255, 2,
function(x)
rgb(x[1], x[2], x[3], alpha=alpha))
}
###### Simulation #####
# Parameters: -------------------------------------------------------------
# population size:
n <- 1000
# initially infected
i0 <- 10
# number of days
Tmax <- 200
# initial average number of "close" encounters (ane) per person per day:
ane <- 80
### "Lockdown" parameters:
# after measures are introduced reduction by factor
red_fac <- 0.50
ane_2 <- ane*(1-red_fac)
# day of introducing measures:
t_lockdown <- 200
# incubation period:
Tinc <- 5
# symptomatic period:
Tsym <-  10
# infectious period:
Tinf <- Tinc + Tsym
# town clusters:
n_town <- 4
within_town <- 100
# expected family size
fam_size <- 4
within_fam <- 100
# probability of overall infecting "R0" (expected value)
R0 <- 3.0
# probability of infecting in a single encounter
p <- R0/(ane*Tinf)
# Overview of infection distributions:
par(mar=c(4.1,4.1,2.1,1.1))
plot(seq(0,ane*Tinf,1), dbinom(seq(0,ane*Tinf,1), ane*Tinf, prob = p), type = 'b', xlab = 'Number of infected', ylab = 'Probability', main = 'Probability of infecting X persons in infectious period', cex.main = 0.8)
grid()
ane*Tinf*p
plot(seq(0,ane,1), dbinom(seq(0,ane,1), ane, prob = p), type = 'b', xlab = 'Number of infected', ylab = 'Probability', main = 'Probability of infecting X persons on one day', cex.main = 0.8, ylim =c(0,1))
grid()
lines(seq(0,ane_2,1), dbinom(seq(0,ane_2,1), ane_2, prob = p), type = 'b', xlab = 'Number of infected', ylab = 'Probability', main = 'Probability of infecting X persons on one day', cex.main = 0.8, col = 2)
grid()
# simulation parameters: --------------------------------------------------
simu <- 100
simu_res <- list()
library(progress)
pb <- progress_bar$new(total = simu)
# Set up simulation dataframes: -------------------------------------------
for(j in 1:simu){
#Data on who is infected:
inf_dat <- as.data.frame(matrix(0, nrow = n, ncol = Tmax))
#initially infected:
inf_dat[1:i0, 1] <- 1
#Individual number of meetings (constant troughout)
ine <- rpois(n, lambda = ane)
ine_2 <- round(ine*(1-red_fac))
### Probabilities of meeting with clusters for family & town
# matrix for relationship:
cluster_matrix <- matrix(1/n, ncol = n, nrow = n)
# Generate town clusters:
for(i in 1:(n_town)){
ind_1 <- round((i-1)*n/n_town)+1
ind_2 <- round((i)*n/n_town)
cluster_matrix[ind_1:ind_2,ind_1:ind_2] <- cluster_matrix[ind_1:ind_2,ind_1:ind_2]*within_town
}
# Generate family clusters:
i<-1
while(i<=n){
temp_fam_size<-rpois(n = 1, fam_size)
ind_1 <- i
if(i+temp_fam_size-1<=n){
ind_2 <- i+temp_fam_size-1
}else{
ind_2 <- n
}
cluster_matrix[ind_1:ind_2,ind_1:ind_2] <- cluster_matrix[ind_1:ind_2,ind_1:ind_2]*within_fam
i <- i + temp_fam_size
}
#Set diagonal to 0:
diag(cluster_matrix) <- 0
#renormalize matrix:
cluster_matrix_norm <- cluster_matrix/rowSums(cluster_matrix)
###407 481 4820
#list of who infects who (depending on round):
#(first dimension is time, second dimension is individual, thrid dimension who gets infected)
inf_trans <- rep(list(rep(list(NA),n)),Tmax)
# function determing who gets infected:
trans_func <- function(ine, p, n, m_probs){
ntrans <- rbinom(1, ine, p)
if(ntrans == 0){return(NA)} else{return(sample(1:n, ntrans, prob = m_probs))}
}
# Start infection rounds:
for(t in 2:Tmax){
# previous round infected:
it_1_ind <- which(inf_dat[,t-1]>0)
if(length(it_1_ind)>0){
# determine all transmission:
if(t<= t_lockdown){
inf_trans[[t]][it_1_ind] <- lapply(it_1_ind, function(x) trans_func(ine[[x]],p,n, m_probs = cluster_matrix_norm[x,]))
}else{
inf_trans[[t]][it_1_ind] <- lapply(it_1_ind, function(x) trans_func(ine_2[[x]],p,n, m_probs = cluster_matrix_norm[x,]))
}
#continue previous round infected:
inf_dat[,t] <- inf_dat[,t-1]
inf_dat[it_1_ind,t] <- inf_dat[it_1_ind,t]+1
#set newly infected persons in current round (only if not NA or positive yet):
indis <- unlist(inf_trans[[t]][it_1_ind])
if(any(is.finite(indis))){
#Check if already NA or infected:
indi_sub <- which(inf_dat[indis,t]==0)
if(length(indi_sub)>0){
inf_dat[indis[indi_sub],t] <- 1
}
}
#set people who are healthy again to NA
indis2 <- which(inf_dat[,t]>Tinf)
if(any(is.finite(indis2))){inf_dat[indis2,t:Tmax] <- NA}
}
# else{
#   inf_dat[,t] <- inf_dat[,t]
# }
}
simu_res[[j]] <- inf_dat
pb$tick()
}
